{"version":3,"sources":["content-sizer.js"],"names":["getComputedStyle","prop","element","value","parseInt","document","body","defaultView","getMaxElement","side","elements","elementsLength","length","elVal","maxVal","Side","capitalizeFirstLetter","i","nodeType","getBoundingClientRect","style","range","createRange","selectNode","getSmallestOffsetLeft","Array","from","getTopLevelElements","reduce","lowest","Math","min","offsetLeft","getAllMeasurements","dimCalc","bodyOffset","bodyScroll","documentElementOffset","documentElementScroll","getAllElements","querySelectorAll","string","charAt","toUpperCase","slice","elementHasRelative","dimension","some","symbol","includes","recursivelyGetHeight","filter","el","nodeName","childNodes","recursivelyGetWidth","heightCalc","offsetHeight","scrollHeight","documentElement","content","clientHeight","furthestElement","apply","max","widthCalc","offsetWidth","scrollWidth","clientWidth","scroll","ZnSize","updateRequester","d","methods","heightMethod","height","widthMethod","width","observer","auto","currentWidth","currentHeight","events","getHeight","getWidth","isSizeChanged","measureAndUpdate","setupMutation","addEventHandlers","forEach","window","addEventListener","handleEvent","bind","removeEventListener","removeEventHandlers","disconnect","e","method","MutationObserver","WebKitMutationObserver","mutations","setTimeout","observe","querySelector","attributes","attributeOldValue","characterData","characterDataOldValue","childList","subtree","originalValue","newValue","tolerance","abs"],"mappings":"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","file":"content-sizer.js","sourceRoot":"../js","sourcesContent":["// Based on: https://github.com/davidjbradshaw/iframe-resizer\n// Goal is to make a simple resize system\n\n/**\n * Get the int value of a property for an element\n * @param prop\n * @param element\n * @returns {number}\n */\nconst getComputedStyle = (prop, element) => {\n  let value = 0\n  element = element || document.body\n  value = document.defaultView.getComputedStyle(element, null)\n  value = value !== null ? value[prop] : 0\n  return parseInt(value, 10)\n}\n\n/**\n * Get the largest element based on the target page side & given elements\n * @param {'right' | 'bottom'} side\n * @param {HTMLElement[]} elements\n * @returns {number}\n */\nconst getMaxElement = (side, elements) => {\n  let elementsLength = elements.length\n  let elVal = 0\n  let maxVal = 0\n\n  let Side = capitalizeFirstLetter(side)\n\n  for (let i = 0; i < elementsLength; i++) {\n    if (elements[i].nodeType === 1) {\n      elVal = elements[i].getBoundingClientRect()[side] + (\n        elements[i].style[`margin${Side}`] === 'auto'\n          ? 0\n          : getComputedStyle(`margin${Side}`, elements[i])\n      )\n    }\n\n    if (elements[i].nodeType === 3) {\n      const range = document.createRange()\n      range.selectNode(elements[i])\n\n      elVal = range.getBoundingClientRect()[side]\n    }\n\n    if (elVal > maxVal) {\n      maxVal = elVal\n    }\n  }\n\n  return maxVal\n}\n\nconst getSmallestOffsetLeft = () => {\n  return Array.from(getTopLevelElements())\n    .reduce((lowest, element) => Math.min(element.offsetLeft, lowest), 0)\n}\n\n/**\n * Gets all the basic measurements from the dimension calculation object\n * @param dimCalc\n * @returns {(*|number)[]}\n */\nconst getAllMeasurements = (dimCalc) => {\n  return [\n    dimCalc.bodyOffset(),\n    dimCalc.bodyScroll(),\n    dimCalc.documentElementOffset(),\n    dimCalc.documentElementScroll()\n  ]\n}\n\n/**\n * Gets all the elements on the page\n * @returns {NodeListOf<Element>}\n */\nconst getAllElements = () => {\n  return document.querySelectorAll('body *')\n}\n\n/**\n * Gets all the immediate children of the body\n * @returns {NodeListOf<Element>}\n */\nconst getTopLevelElements = () => {\n  return document.querySelectorAll('body > *')\n}\n\n/**\n * Capitalizes the first letter of a string\n * @param string\n * @returns {string}\n */\nconst capitalizeFirstLetter = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1)\n}\n\n/**\n * Determine if an element has its height set to something relative to its parent(s)\n * @param {HTMLElement} element\n */\nconst elementHasRelative = dimension => element => ['%', 'vh', 'vw', 'vmin', 'vmax'].some(symbol => element.style[dimension].includes(symbol))\n\n/**\n * \n * @param  {...HTMLElement} elements \n */\nconst recursivelyGetHeight = elements => {\n  elements = Array.from(elements).filter(el => el.nodeName !== 'SCRIPT')\n\n  if (elements.length === 1 && elementHasRelative('height')(elements[0])) {\n    return recursivelyGetHeight(elements[0].childNodes)\n  }\n\n  return getMaxElement('bottom', elements)\n}\n\nconst recursivelyGetWidth = elements => {\n  elements = Array.from(elements).filter(el => el.nodeName !== 'SCRIPT')\n\n  if (elements.length === 1) {\n    return recursivelyGetWidth(elements[0].childNodes)\n  }\n\n  return getMaxElement('right', elements)\n}\n\nconst heightCalc = {\n  /**\n   * Get the body.offsetHeight\n   * @returns {number}\n   */\n  bodyOffset: () => {\n    return document.body.offsetHeight + getComputedStyle('marginTop') + getComputedStyle('marginBottom')\n  },\n  /**\n   * Get the body.scrollHeight\n   * @returns {number}\n   */\n  bodyScroll: () => {\n    return document.body.scrollHeight\n  },\n  /**\n   * Get the documentElement.offsetHeight\n   * @returns {number}\n   */\n  documentElementOffset: () => {\n    return document.documentElement.offsetHeight\n  },\n  /**\n   * Get the documentElement.scrollHeight\n   * @returns {number}\n   */\n  documentElementScroll: () => {\n    return document.documentElement.scrollHeight\n  },\n  /**\n   * Get the total width of the top-level elements on the page\n   * @returns {number}\n   */\n  content: () => {\n    if (document.body.scrollHeight > document.body.clientHeight) {\n      return document.body.scrollHeight\n    }\n\n    return recursivelyGetHeight(getTopLevelElements())\n  },\n  /**\n   * Get the height of the element that's closest to the bottom of the page\n   * @returns {number}\n   */\n  furthestElement: () => {\n    return getMaxElement('bottom', getAllElements())\n  },\n  /**\n   * Get the min value of all the base measurements\n   * @returns {number}\n   */\n  min: () => {\n    return Math.min.apply(null, getAllMeasurements(heightCalc))\n  },\n  /**\n   * Get the max value of all the base measurements\n   * @returns {number}\n   */\n  max: () => {\n    return Math.max.apply(null, getAllMeasurements(heightCalc))\n  }\n}\n\nconst widthCalc = {\n  /**\n   * Get the body.offsetWidth\n   * @returns {number}\n   */\n  bodyOffset: () => {\n    return document.body.offsetWidth\n  },\n  /**\n   * Get the body.scrollWidth\n   * @returns {number}\n   */\n  bodyScroll: () => {\n    return document.body.scrollWidth\n  },\n  /**\n   * Get the documentElement.offsetWidth\n   * @returns {number}\n   */\n  documentElementOffset: () => {\n    return document.documentElement.offsetWidth\n  },\n  /**\n   * Get the documentElement.scrollWidth\n   * @returns {number}\n   */\n  documentElementScroll: () => {\n    return document.documentElement.scrollWidth\n  },\n  /**\n   * Get the width of the element that's furthest to the right of the page\n   * @returns {number}\n   */\n  furthestElement: () => {\n    return getMaxElement('right', getTopLevelElements())\n  },\n  /**\n   * Get the total width of the top-level elements on the page\n   * @returns {number}\n   */\n  content: () => {\n    if (document.body.scrollWidth > document.body.clientWidth) {\n      return getSmallestOffsetLeft() + document.body.scrollWidth\n    }\n\n    return getSmallestOffsetLeft() + recursivelyGetWidth(getTopLevelElements())\n  },\n  /**\n   * Get the min value of all the base measurements\n   * @returns {number}\n   */\n  min: () => {\n    return Math.min.apply(null, getAllMeasurements(widthCalc))\n  },\n  /**\n   * Get the max value of all the base measurements\n   * @returns {number}\n   */\n  max: () => {\n    return Math.max.apply(null, getAllMeasurements(widthCalc))\n  },\n  /**\n   * Gets the max of body.scrollWidth & documentElement.scrollWidth\n   * @returns {number}\n   */\n  scroll: () => {\n    return Math.max(widthCalc.bodyScroll(), widthCalc.documentElementScroll())\n  }\n}\n\nexport default class ZnSize {\n  /**\n   * UpdateRequester Function\n   *\n   * @callback UpdateRequester\n   * @param {{ width: string, height: string }} dimensions\n   *\n   * @returns {*}\n   */\n\n  /**\n   * ZnSize\n   * Auto-detects sizing needs, and executes resizing on command\n   * \n   * @param {UpdateRequester} updateRequester\n   * @param {Object} methods\n   * @param {'bodyOffset' | 'bodyScroll' | 'documentElementOffset' | 'documentElementScroll' | 'furthestElement' | 'min' | 'max'} methods.height\n   * @param {'bodyOffset' | 'bodyScroll' | 'documentElementOffset' | 'documentElementScroll' | 'furthestElement' | 'min' | 'max' | 'scroll'} methods.width\n   */\n  constructor (updateRequester = d => {}, methods = {}) {\n    this.updateRequester = updateRequester\n    this.heightMethod = typeof methods.height === 'string' ? methods.height : 'content'\n    this.widthMethod = typeof methods.width === 'string' ? methods.width : 'content'\n    this.observer = null\n    this.auto = false\n    this.currentWidth = 0\n    this.currentHeight = 0\n    this.events = [\n      'animationstart',\n      'webkitAnimationStart',\n      'animationiteration',\n      'webkitAnimationIteration',\n      'animationend',\n      'webkitAnimationEnd',\n      'orientationchange',\n      'transitionstart',\n      'webkitTransitionStart',\n      'MSTransitionStart',\n      'oTransitionStart',\n      'otransitionstart',\n      'transitioniteration',\n      'webkitTransitionIteration',\n      'MSTransitionIteration',\n      'oTransitionIteration',\n      'otransitioniteration',\n      'transitionend',\n      'webkitTransitionEnd',\n      'MSTransitionEnd',\n      'oTransitionEnd',\n      'otransitionend'\n    ]\n  }\n\n  /**\n   * Measures Page dimensions and calls updater function with dimensions if changed.\n   */\n  measureAndUpdate () {\n    const height = this.currentHeight\n    const width = this.currentWidth\n\n    this.currentHeight = this.getHeight()\n    this.currentWidth = this.getWidth()\n\n    if (this.isSizeChanged(height, this.currentHeight, 2) || this.isSizeChanged(width, this.currentWidth, 2)) {\n      this.updateRequester({\n        width: `${this.currentWidth}px`,\n        height: `${this.currentHeight}px`\n      })\n    }\n  }\n\n  /**\n   * Initialize autosizing via Mutation Observer\n   */\n  autoSize () {\n    if (this.auto) {\n      return null\n    }\n\n    this.auto = true\n\n    this.measureAndUpdate()\n    this.observer = this.setupMutation()\n    this.addEventHandlers()\n  }\n\n  addEventHandlers () {\n    this.events.forEach(value => {\n      window.addEventListener(value, this.handleEvent.bind(this))\n    })\n  }\n\n  removeEventHandlers () {\n    this.events.forEach(value => {\n      window.removeEventListener(value, this.handleEvent.bind(this))\n    })\n  }\n\n  stopAutoSize () {\n    this.auto = false\n    this.removeEventHandlers()\n\n    if (!this.observer) return null\n    \n    this.observer.disconnect()\n    this.observer = false\n  }\n\n  handleEvent (e) {\n    this.measureAndUpdate()\n  }\n\n  /**\n   * Get the page width\n   * @param method\n   * @returns {number}\n   */\n  getWidth (method = this.widthMethod) {\n    return widthCalc[method]()\n  }\n\n  /**\n   * Get the page height\n   * @param method\n   * @returns {number}\n   */\n  getHeight (method = this.heightMethod) {\n    return heightCalc[method]()\n  }\n\n  /**\n   * Sets up MutationObserver\n   * @returns {MutationObserver}\n   */\n  setupMutation () {\n    const MutationClass = window.MutationObserver || window.WebKitMutationObserver\n\n    const observer = new MutationClass((mutations, observer) => {\n      setTimeout(() => {\n        this.measureAndUpdate()\n      }, 16)\n    })\n\n    observer.observe(document.querySelector('body'), {\n      attributes: true,\n      attributeOldValue: false,\n      characterData: true,\n      characterDataOldValue: false,\n      childList: true,\n      subtree: true\n    })\n\n    return observer\n  }\n\n  /**\n   * Check if a size has changed\n   * @param originalValue\n   * @param newValue\n   * @param tolerance\n   * @returns {boolean}\n   */\n  isSizeChanged (originalValue, newValue, tolerance = 0) {\n    return Math.abs(originalValue - newValue) >= tolerance\n  }\n}\n"]}