{"version":3,"sources":["ZnSize.js"],"names":["getComputedStyle","prop","element","value","parseInt","document","body","defaultView","getMaxElement","side","elements","elementsLength","length","elVal","maxVal","Side","capitalizeFirstLetter","i","getBoundingClientRect","getSmallestOffsetLeft","Array","from","getTopLevelElements","reduce","lowest","Math","min","offsetLeft","getAllMeasurements","dimCalc","bodyOffset","bodyScroll","documentElementOffset","documentElementScroll","getAllElements","querySelectorAll","string","charAt","toUpperCase","slice","heightCalc","offsetHeight","scrollHeight","documentElement","furthestElement","apply","max","widthCalc","offsetWidth","scrollWidth","content","clientWidth","scroll","ZnSize","updateRequester","d","methods","heightMethod","height","widthMethod","width","observer","auto","currentWidth","currentHeight","events","getHeight","getWidth","isSizeChanged","measureAndUpdate","setupMutation","addEventHandlers","forEach","window","addEventListener","handleEvent","bind","removeEventListener","removeEventHandlers","disconnect","e","method","MutationObserver","WebKitMutationObserver","mutations","setTimeout","observe","querySelector","attributes","attributeOldValue","characterData","characterDataOldValue","childList","subtree","originalValue","newValue","tolerance","abs"],"mappings":"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","file":"ZnSize.js","sourceRoot":"../js","sourcesContent":["// Based on: https://github.com/davidjbradshaw/iframe-resizer\n// Goal is to make a simple resize system\n\n/**\n * Get the int value of a property for an element\n * @param prop\n * @param element\n * @returns {number}\n */\nconst getComputedStyle = (prop, element) => {\n  let value = 0\n  element = element || document.body\n  value = document.defaultView.getComputedStyle(element, null)\n  value = value !== null ? value[prop] : 0\n  return parseInt(value, 10)\n}\n\n/**\n * Get the largest element based on the target page side & given elements\n * @param side\n * @param elements\n * @returns {number}\n */\nconst getMaxElement = (side, elements) => {\n  let elementsLength = elements.length\n  let elVal = 0\n  let maxVal = 0\n\n  let Side = capitalizeFirstLetter(side)\n\n  for (let i = 0; i < elementsLength; i++) {\n    elVal = elements[i].getBoundingClientRect()[side] + getComputedStyle(`margin${Side}`, elements[i])\n\n    if (elVal > maxVal) {\n      maxVal = elVal\n    }\n  }\n\n  return maxVal\n}\n\nconst getSmallestOffsetLeft = () => {\n  return Array.from(getTopLevelElements())\n    .reduce((lowest, element) => Math.min(element.offsetLeft, lowest), 0)\n}\n\n/**\n * Gets all the basic measurements from the dimension calculation object\n * @param dimCalc\n * @returns {(*|number)[]}\n */\nconst getAllMeasurements = (dimCalc) => {\n  return [\n    dimCalc.bodyOffset(),\n    dimCalc.bodyScroll(),\n    dimCalc.documentElementOffset(),\n    dimCalc.documentElementScroll()\n  ]\n}\n\n/**\n * Gets all the elements on the page\n * @returns {NodeListOf<Element>}\n */\nconst getAllElements = () => {\n  return document.querySelectorAll('body *')\n}\n\n/**\n * Gets all the immediate children of the body\n * @returns {NodeListOf<Element>}\n */\nconst getTopLevelElements = () => {\n  return document.querySelectorAll('body > *')\n}\n\n/**\n * Capitalizes the first letter of a string\n * @param string\n * @returns {string}\n */\nconst capitalizeFirstLetter = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1)\n}\n\nconst heightCalc = {\n  /**\n   * Get the body.offsetHeight\n   * @returns {number}\n   */\n  bodyOffset: () => {\n    return document.body.offsetHeight + getComputedStyle('marginTop') + getComputedStyle('marginBottom')\n  },\n  /**\n   * Get the body.scrollHeight\n   * @returns {number}\n   */\n  bodyScroll: () => {\n    return document.body.scrollHeight\n  },\n  /**\n   * Get the documentElement.offsetHeight\n   * @returns {number}\n   */\n  documentElementOffset: () => {\n    return document.documentElement.offsetHeight\n  },\n  /**\n   * Get the documentElement.scrollHeight\n   * @returns {number}\n   */\n  documentElementScroll: () => {\n    return document.documentElement.scrollHeight\n  },\n  /**\n   * Get the height of the element that's closest to the bottom of the page\n   * @returns {number}\n   */\n  furthestElement: () => {\n    return getMaxElement('bottom', getAllElements())\n  },\n  /**\n   * Get the min value of all the base measurements\n   * @returns {number}\n   */\n  min: () => {\n    return Math.min.apply(null, getAllMeasurements(heightCalc))\n  },\n  /**\n   * Get the max value of all the base measurements\n   * @returns {number}\n   */\n  max: () => {\n    return Math.max.apply(null, getAllMeasurements(heightCalc))\n  }\n}\n\nconst widthCalc = {\n  /**\n   * Get the body.offsetWidth\n   * @returns {number}\n   */\n  bodyOffset: () => {\n    return document.body.offsetWidth\n  },\n  /**\n   * Get the body.scrollWidth\n   * @returns {number}\n   */\n  bodyScroll: () => {\n    return document.body.scrollWidth\n  },\n  /**\n   * Get the documentElement.offsetWidth\n   * @returns {number}\n   */\n  documentElementOffset: () => {\n    return document.documentElement.offsetWidth\n  },\n  /**\n   * Get the documentElement.scrollWidth\n   * @returns {number}\n   */\n  documentElementScroll: () => {\n    return document.documentElement.scrollWidth\n  },\n  /**\n   * Get the width of the element that's furthest to the right of the page\n   * @returns {number}\n   */\n  furthestElement: () => {\n    return getMaxElement('right', getTopLevelElements())\n  },\n  /**\n   * Get the total width of the top-level elements on the page\n   * @returns {number}\n   */\n  content: () => {\n    if (document.body.scrollWidth > document.body.clientWidth) {\n      return getSmallestOffsetLeft() + document.body.scrollWidth\n    }\n\n    return getSmallestOffsetLeft() + widthCalc.furthestElement()\n  },\n  /**\n   * Get the min value of all the base measurements\n   * @returns {number}\n   */\n  min: () => {\n    return Math.min.apply(null, getAllMeasurements(widthCalc))\n  },\n  /**\n   * Get the max value of all the base measurements\n   * @returns {number}\n   */\n  max: () => {\n    return Math.max.apply(null, getAllMeasurements(widthCalc))\n  },\n  /**\n   * Gets the max of body.scrollWidth & documentElement.scrollWidth\n   * @returns {number}\n   */\n  scroll: () => {\n    return Math.max(widthCalc.bodyScroll(), widthCalc.documentElementScroll())\n  }\n}\n\nexport default class ZnSize {\n  /**\n   * UpdateRequester Function\n   *\n   * @callback UpdateRequester\n   * @param {{ width: string, height: string }} dimensions\n   *\n   * @returns {*}\n   */\n\n  /**\n   * ZnSize\n   * Auto-detects sizing needs, and executes resizing on command\n   * \n   * @param {UpdateRequester} updateRequester\n   * @param {Object} methods\n   * @param {'bodyOffset' | 'bodyScroll' | 'documentElementOffset' | 'documentElementScroll' | 'furthestElement' | 'min' | 'max'} methods.height\n   * @param {'bodyOffset' | 'bodyScroll' | 'documentElementOffset' | 'documentElementScroll' | 'furthestElement' | 'min' | 'max' | 'scroll'} methods.width\n   */\n  constructor (updateRequester = d => {}, methods = {}) {\n    this.updateRequester = updateRequester\n    this.heightMethod = typeof methods.height === 'string' ? methods.height : 'content'\n    this.widthMethod = typeof methods.width === 'string' ? methods.width : 'content'\n    this.observer = null\n    this.auto = false\n    this.currentWidth = 0\n    this.currentHeight = 0\n    this.events = [\n      'animationstart',\n      'webkitAnimationStart',\n      'animationiteration',\n      'webkitAnimationIteration',\n      'animationend',\n      'webkitAnimationEnd',\n      'orientationchange',\n      'transitionstart',\n      'webkitTransitionStart',\n      'MSTransitionStart',\n      'oTransitionStart',\n      'otransitionstart',\n      'transitioniteration',\n      'webkitTransitionIteration',\n      'MSTransitionIteration',\n      'oTransitionIteration',\n      'otransitioniteration',\n      'transitionend',\n      'webkitTransitionEnd',\n      'MSTransitionEnd',\n      'oTransitionEnd',\n      'otransitionend'\n    ]\n  }\n\n  /**\n   * Measures Page dimensions and calls updater function with dimensions if changed.\n   */\n  measureAndUpdate () {\n    const height = this.currentHeight\n    const width = this.currentWidth\n\n    this.currentHeight = this.getHeight()\n    this.currentWidth = this.getWidth()\n\n    if (this.isSizeChanged(height, this.currentHeight, 2) || this.isSizeChanged(width, this.currentWidth, 2)) {\n      this.updateRequester({\n        width: `${this.currentWidth}px`,\n        height: `${this.currentHeight}px`\n      })\n    }\n  }\n\n  /**\n   * Initialize autosizing via Mutation Observer\n   */\n  autoSize () {\n    if (this.auto) {\n      return null\n    }\n\n    this.auto = true\n\n    this.measureAndUpdate()\n    this.observer = this.setupMutation()\n    this.addEventHandlers()\n  }\n\n  addEventHandlers () {\n    this.events.forEach(value => {\n      window.addEventListener(value, this.handleEvent.bind(this))\n    })\n  }\n\n  removeEventHandlers () {\n    this.events.forEach(value => {\n      window.removeEventListener(value, this.handleEvent.bind(this))\n    })\n  }\n\n  stopAutoSize () {\n    this.auto = false\n    this.removeEventHandlers()\n\n    if (!this.observer) return null\n    \n    this.observer.disconnect()\n    this.observer = false\n  }\n\n  handleEvent (e) {\n    this.measureAndUpdate()\n  }\n\n  /**\n   * Get the page width\n   * @param method\n   * @returns {number}\n   */\n  getWidth (method = this.widthMethod) {\n    return widthCalc[method]()\n  }\n\n  /**\n   * Get the page height\n   * @param method\n   * @returns {number}\n   */\n  getHeight (method = this.heightMethod) {\n    return heightCalc[method]()\n  }\n\n  /**\n   * Sets up MutationObserver\n   * @returns {MutationObserver}\n   */\n  setupMutation () {\n    const MutationClass = window.MutationObserver || window.WebKitMutationObserver\n\n    const observer = new MutationClass((mutations, observer) => {\n      setTimeout(() => {\n        this.measureAndUpdate()\n      }, 16)\n    })\n\n    observer.observe(document.querySelector('body'), {\n      attributes: true,\n      attributeOldValue: false,\n      characterData: true,\n      characterDataOldValue: false,\n      childList: true,\n      subtree: true\n    })\n\n    return observer\n  }\n\n  /**\n   * Check if a size has changed\n   * @param originalValue\n   * @param newValue\n   * @param tolerance\n   * @returns {boolean}\n   */\n  isSizeChanged (originalValue, newValue, tolerance = 0) {\n    return Math.abs(originalValue - newValue) >= tolerance\n  }\n}\n"]}